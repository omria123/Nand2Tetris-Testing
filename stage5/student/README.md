

הגענו לאחד השיאים של המערך, אנחנו הולכים לסיים את בניית המעבד והמחשב.


בשביל זה נדבר קצת על ארכיטקטורה והיסטוריה:


הארכיטקטורה המודרנית הקיימת בימינו היא ארכיטקטורת ואן-ניומן.
הארכיטקטורה קובעת כי המחשב יכול בצורה מאוד פשטנית להיות מחולק ל3 חלקים:
1. מעבד
2. זיכרון
3. ערוצי תקשורת ביניהם - נקראים bus (ביחיד)

המעבד יודע כאמור לקבל פעולה בינארית מהזיכרון ולהבין ממנה מה לעשות.
לדוגמא: תטען את המידע השמור בכתובת שמחזיק הרגיסטר X לרגיסטר Y. בפעולה הבאה תעלה את Y ב 1,
ואז תחזיר את Y לזיכרון (פעולה פשוטה של var++).

כאשר הוא רוצה לפנות לזיכרון הוא פונה אליו באמצעות הbusים השונים:
1. על הaddress bus הוא ישים את הכתובת אליה הוא רוצה להתייחס.
2. על הcontrol bus הוא יגיד לזיכרון מה הוא רוצה לעשות (לקרוא/לכתוב).
3. על ה data bus יעבור המידע עצמו מהזיכרון למעבד ולהפך (תלוי בסוג הפעולה).


אחרי לקיחת פעולה fetch יתבצע execute - המעבד יפרק את הפקודה, ויבין ממנה באיזה רגיסטרים להשתמש,
איזו פעולה הALU אמור לבצע, ואיפה לשים את התוצאה.
במקרים מסוימים תתבצע קפיצה מה שידרוש מהמעבד לשנות את הPC על שיבחר בסיבוב הבא פקודה אחרת להביא מאותו הזיכרון.



הבעיה היא שיש המון קשיים בלבנות את המודל הזה, כאשר אנחנו משלבים את הזיכרון שמחזיק את הפקודות
ואת שאר הזיכרון באותו המקום (מה שקורה בימינו) אנחנו צריכים להבין בכל סיבוב כאשר אנחנו מבצעים 
קריאה מהזיכרון, לשם מה הקריאה הזאת? לאיפה אני צריך לכתוב את התוצאה של הקריאה? לתוך רגיסטר 
רגיל או לתוך PC? ועוד דילמות דומות.

לשם כך נחזור טיפה בהיסטוריה, ונעבור למודל אחר בשם ארכיטקטורת הרווארד. 
לפי המודל הזה אנחנו מחלקים את הזיכרון לשני חלקים: 
1. זיכרון קוד - זיכרון שניתן אך ורק לקרוא ממנו פקודות.
2. זיכרון ששומר מידע - זיכרון שניתן לכתוב ולקרוא ממנו.

בעבר כאשר רצו להריץ תוכנה, היו צריכים להשתמש בלוחיות פיזיות, בהן סומנו חורים (שסימנו 0 או 1), 
לקחו את הלוחיות ושמו אותן בתוך ה"מחשב" שהיה יודע לרוץ עליהן אחת אחרי השנייה ולקפוץ לפעמים מלוחית ללוחית.

הדבר יפשט משמעותית את היכולת שלכם לממש את ארכיטקטורת המחשב.
את זיכרון ה ROM תקבלו כמובן בחינם.


מה שישאר לכם לכתוב:
Memory.hdl
CPU.hdl
Computer.hdl

לפני שתתחילו, מומלץ לעבור על המצגת המצורפת.



אם תרצו לבדוק את עצמכם בנוגע ל Computer.hdl תוכלו להריץ את תוכניות הhack שקיבלתם ב zip.
Add.hack - Add 2 and 3 and writes the result to RAM[0]
Max.hack - Put in RAM[2] the result of Max(RAM[0], RAM[1])
Rect.hack - Draw rectangle of (l,w) = (RAM[0], 15) in the top left screen.




עליכם להגיש כמו בתרגילים הקודמים את קבצי hdl,tst,cmp בתיקיית zip

